import sys
from typing import Any, Iterator, Optional, Tuple

# Some type differences under python3
if sys.version_info[0] >= 3:
  long = int
  buffer_type = memoryview
else:
  buffer_type = buffer

class ndarray(object):
  # https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html
  def __init__(self,
               shape,
               dtype=...,
               buffer=...,
               offset=...,
               strides=...,
               order=...) -> None: ...

  def __getattr__(self, name) -> Any: ...

  # We need to add all special methods used for protocols explicitly
  # (b/33779140). Everything else is optional.

  # https://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html#array-attributes
  @property
  def flags(self) -> Any: ...
  @property
  def shape(self) -> Tuple[int, ...]: ...
  @property
  def strides(self) -> Tuple[int, ...]: ...
  @property
  def data(self) -> buffer_type: ...
  @property
  def size(self) -> int: ...
  @property
  def itemsize(self) -> int: ...
  @property
  def nbytes(self) -> int: ...
  @property
  def base(self) -> Optional[ndarray]: ...

  @property
  def T(self) -> ndarray: ...
  @property
  def real(self) -> ndarray: ...
  @property
  def imag(self) -> ndarray: ...
  @property
  def flat(self) -> Any: ...
  @property
  def ctypes(self) -> Any: ...
  @property
  def __array_interface__(self) -> dict: ...

  # TODO(b/159138694): add array methods:
  # https://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html#array-methods

  # https://docs.python.org/2/reference/datamodel.html
  def __len__(self) -> int: ...
  def __getitem__(self, key) -> Any: ...
  def __setitem__(self, key, value): ...
  def __iter__(self) -> Any: ...
  def __contains__(self, key) -> bool: ...
  def __reversed__(self) -> Iterator[Any]: ...

  # __getitem__ should suffice here, but pytype needs these (b/65407594)
  def __getslice__(self, i, j) -> Any: ...
  def __setslice__(self, i, j, value) -> Any: ...

  def __complex__(self) -> complex: ...
  def __int__(self) -> int: ...
  def __long__(self) -> long: ...
  def __float__(self) -> float: ...
  def __oct__(self) -> str: ...
  def __hex__(self) -> str: ...
  def __nonzero__(self) -> bool: ...

  def __index__(self) -> int: ...

  def __copy__(self, order = ...) -> ndarray: ...
  def __deepcopy__(self, order = ...) -> ndarray: ...

  # https://github.com/numpy/numpy/blob/v1.13.0/numpy/lib/mixins.py#L63-L181

  # TODO(b/159138694): add overloads (returning ndarray) for cases where other
  # is known not to define __array_priority__ or __array_ufunc__, such as for
  # numbers or other numpy arrays. Or even better, use protocols (once they
  # work).

  def __lt__(self, other): ...
  def __le__(self, other): ...
  def __eq__(self, other): ...
  def __ne__(self, other): ...
  def __gt__(self, other): ...
  def __ge__(self, other): ...

  def __add__(self, other): ...
  def __radd__(self, other): ...
  def __iadd__(self, other): ...

  def __sub__(self, other): ...
  def __rsub__(self, other): ...
  def __isub__(self, other): ...

  def __mul__(self, other): ...
  def __rmul__(self, other): ...
  def __imul__(self, other): ...

  def __div__(self, other): ...
  def __rdiv__(self, other): ...
  def __idiv__(self, other): ...

  def __truediv__(self, other): ...
  def __rtruediv__(self, other): ...
  def __itruediv__(self, other): ...

  def __floordiv__(self, other): ...
  def __rfloordiv__(self, other): ...
  def __ifloordiv__(self, other): ...

  def __mod__(self, other): ...
  def __rmod__(self, other): ...
  def __imod__(self, other): ...

  def __divmod__(self, other): ...
  def __rdivmod__(self, other): ...

  # NumPy's __pow__ doesn't handle a third argument
  def __pow__(self, other): ...
  def __rpow__(self, other): ...
  def __ipow__(self, other): ...

  def __lshift__(self, other): ...
  def __rlshift__(self, other): ...
  def __ilshift__(self, other): ...

  def __rshift__(self, other): ...
  def __rrshift__(self, other): ...
  def __irshift__(self, other): ...

  def __and__(self, other): ...
  def __rand__(self, other): ...
  def __iand__(self, other): ...

  def __xor__(self, other): ...
  def __rxor__(self, other): ...
  def __ixor__(self, other): ...

  def __or__(self, other): ...
  def __ror__(self, other): ...
  def __ior__(self, other): ...

  def __neg__(self) -> ndarray: ...
  def __pos__(self) -> ndarray: ...
  def __abs__(self) -> ndarray: ...
  def __invert__(self) -> ndarray: ...

  if sys.version_info >= (3, 5):
    def __matmul__(self, other): ...
    def __rmatmul__(self, other): ...
    def __imatmul__(self, other): ...


def array(object: Any,
          dtype: Any = ...,
          copy: bool = ...,
          order: str = ...,
          subok: bool = ...,
          ndmin: int = ...) -> ndarray: ...


def asarray(a: Any,
            dtype: Any = ...,
            order: Optional[str] = ...) -> ndarray: ...


def __getattr__(name) -> Any: ...
