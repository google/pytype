# These stubs are necessary because pytype can't yet parse the canonical attr
# stubs due to
# https://github.com/google/pytype/issues/315 and
# https://github.com/google/pytype/issues/321.
# They were generated by running pytype over the attr source code, with the
# following manual changes:
# * The Python 2 and Python 3 stubs for _compat and _make were merged. (For the
#   remaining stubs, the two versions were identical.)
# * The definition of Factory was changed from Any to a function signature.
# * The `init` argument to attrs and attrib was annotated.

import __future__
import attr._make
from typing import Any, Callable, List, Type, TypeVar

Attribute: Type[attr._make.Attribute]
NOTHING: attr._make._Nothing
__all__: List[str]
__author__: str
__copyright__: str
__description__: str
__email__: str
__license__: str
__title__: str
__uri__: str
__url__: str
__version__: str
absolute_import: __future__._Feature
converters: Any
dataclass: Callable
division: __future__._Feature
exceptions: Any
filters: Any
print_function: __future__._Feature
validators: Any

_S = TypeVar('_S')
_T = TypeVar('_T')
_T0 = TypeVar('_T0')
_T2 = TypeVar('_T2')
_T3 = TypeVar('_T3')
_T4 = TypeVar('_T4')
_T5 = TypeVar('_T5')

Factory = attr._make.Factory
def asdict(inst, recurse = ..., filter = ..., dict_factory = ..., retain_collection_types = ...) -> Any: ...
def assoc(inst: _T0, **changes) -> _T0: ...
def astuple(inst, recurse = ..., filter = ..., tuple_factory = ..., retain_collection_types = ...) -> Any: ...
attrib = attr._make.attrib
attributes = attr._make.attrs
attrs = attr._make.attrs
def evolve(inst, **changes) -> Any: ...
def fields(cls) -> Any: ...
def fields_dict(cls) -> Any: ...
def get_run_validators() -> bool: ...
def has(cls) -> bool: ...
ib = attr._make.attrib
def make_class(name, attrs, bases = ..., **attributes_arguments) -> Any: ...
@overload
def partial(__func: Callable[[_T], _S], __arg: _T) -> Callable[[], _S]: ...
@overload
def partial(__func: Callable[[_T, _T2], _S], __arg: _T) -> Callable[[_T2], _S]: ...
@overload
def partial(__func: Callable[[_T, _T2], _S], __arg1: _T, __arg2: _T2) -> Callable[[], _S]: ...
@overload
def partial(__func: Callable[[_T, _T2, _T3], _S], __arg: _T) -> Callable[[_T2, _T3], _S]: ...
@overload
def partial(__func: Callable[[_T, _T2, _T3], _S], __arg1: _T, __arg2: _T2) -> Callable[[_T3], _S]: ...
@overload
def partial(__func: Callable[[_T, _T2, _T3], _S], __arg1: _T, __arg2: _T2, __arg3: _T3) -> Callable[[], _S]: ...
@overload
def partial(__func: Callable[[_T, _T2, _T3, _T4], _S], __arg: _T) -> Callable[[_T2, _T3, _T4], _S]: ...
@overload
def partial(__func: Callable[[_T, _T2, _T3, _T4], _S], __arg1: _T, __arg2: _T2) -> Callable[[_T3, _T4], _S]: ...
@overload
def partial(__func: Callable[[_T, _T2, _T3, _T4], _S], __arg1: _T, __arg2: _T2, __arg3: _T3) -> Callable[[_T4], _S]: ...
@overload
def partial(__func: Callable[[_T, _T2, _T3, _T4], _S], __arg1: _T, __arg2: _T2, __arg3: _T3, __arg4: _T4) -> Callable[[], _S]: ...
@overload
def partial(__func: Callable[[_T, _T2, _T3, _T4, _T5], _S], __arg: _T) -> Callable[[_T2, _T3, _T4, _T5], _S]: ...
@overload
def partial(__func: Callable[[_T, _T2, _T3, _T4, _T5], _S], __arg1: _T, __arg2: _T2) -> Callable[[_T3, _T4, _T5], _S]: ...
@overload
def partial(__func: Callable[[_T, _T2, _T3, _T4, _T5], _S], __arg1: _T, __arg2: _T2, __arg3: _T3) -> Callable[[_T4, _T5], _S]: ...
@overload
def partial(__func: Callable[[_T, _T2, _T3, _T4, _T5], _S], __arg1: _T, __arg2: _T2, __arg3: _T3, __arg4: _T4) -> Callable[[_T5], _S]: ...
@overload
def partial(__func: Callable[[_T, _T2, _T3, _T4, _T5], _S], __arg1: _T, __arg2: _T2, __arg3: _T3, __arg4: _T4, __arg5: _T5) -> Callable[[], _S]: ...
@overload
def partial(__func: Callable[..., _S], *args, **kwargs) -> Callable[..., _S]: ...
s = attr._make.attrs
def set_run_validators(run) -> None: ...
def validate(inst) -> None: ...
# Keep this at the end so it doesn't shadow the module
attr = attr._make.attrib
