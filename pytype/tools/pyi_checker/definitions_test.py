"""Tests for pyi_checker definitions.

These are sanity checks to make sure from_node definitions work.
"""

import textwrap

from pytype.tools.pyi_checker import definitions
from typed_ast import ast3
import unittest


class DefinitionFromNodeTest(unittest.TestCase):

  def parse(self, source):
    return ast3.parse(source)

  def parse_stmt(self, source):
    """Helper for parsing single statements."""
    return ast3.parse(source).body[0]

  def parse_expr(self, source):
    """Helper for parsing single expressions."""
    return ast3.parse(source, mode="eval").body

  def _make_func(self, name, lineno=1, col_offset=0, params=None, vararg=None,
                 kwonlyargs=None, kwarg=None, decorators=None, is_async=False):
    params = params or []
    kwonlyargs = kwonlyargs or []
    decorators = decorators or []
    return definitions.Function(name=name, lineno=lineno, col_offset=col_offset,
                                params=params, vararg=vararg,
                                kwonlyargs=kwonlyargs, kwarg=kwarg,
                                decorators=decorators, is_async=is_async)

  def _make_arg(self, name, lineno=1, col_offset=0, has_default=False):
    return definitions.Argument(name=name, lineno=lineno, col_offset=col_offset,
                                has_default=has_default)

  def test_function_basic(self):
    node = self.parse_stmt("def foo(): pass")
    expected = self._make_func(name="foo")
    actual = definitions.Function.from_node(node)
    self.assertEqual(expected, actual)

  def test_function_all_args(self):
    func_str = "def foo(arg1, arg2=2, *var, key1, key2=2, **keys): pass"
    node = self.parse_stmt(func_str)
    expected = self._make_func(
        name="foo",
        params=[self._make_arg("arg1", col_offset=8),
                self._make_arg("arg2", col_offset=14, has_default=True)],
        vararg=self._make_arg("var", col_offset=23),
        kwonlyargs=[self._make_arg("key1", col_offset=28),
                    self._make_arg("key2", col_offset=34, has_default=True)],
        kwarg=self._make_arg("keys", col_offset=44))
    actual = definitions.Function.from_node(node)
    self.assertEqual(expected, actual)

  def test_function_decorators(self):
    func_str = textwrap.dedent("""\
        @some_decorator
        @another_decorator
        def test():
          pass
        """)
    node = self.parse_stmt(func_str)
    expected = self._make_func(
        name="test",
        lineno=1,  # Decorators all count as 1 line.
        decorators=["some_decorator", "another_decorator"])
    actual = definitions.Function.from_node(node)
    self.assertEqual(expected, actual)

  def test_function_async(self):
    func_str = "async def test(): pass"
    node = self.parse_stmt(func_str)
    expected = self._make_func(
        name="test",
        col_offset=6,  # "async" doesn't count as part of definition.
        is_async=True)
    actual = definitions.Function.from_node(node)
    self.assertEqual(expected, actual)

  def test_function_sigs_differ(self):
    # Since definitions are dataclasses, they're compared is if they were tuples
    # of elements. Therefore these two Function instances should be considered
    # different, since they have different keyword-only argument orders.
    # The richer comparison performed by the pyi checker would consider them
    # the same, since keyword-only argument order doesn't really matter.
    func1 = definitions.Function.from_node(
        self.parse_stmt("def foo(a, *c, d, e): pass"))
    func2 = definitions.Function.from_node(
        self.parse_stmt("def foo(a, *c, e, d): pass"))
    self.assertNotEqual(func1, func2)

  def test_variable(self):
    node = self.parse_expr("x")
    expected = definitions.Variable(name="x", lineno=1, col_offset=0)
    actual = definitions.Variable.from_node(node)
    self.assertEqual(expected, actual)

  def test_class_members(self):
    # Classes are generated by the DefinitionFinder visitor passing in the
    # class def, the list of methods, the list of fields and any nested classes.
    # This test represents this by generating each piece separately.
    class_stmt = textwrap.dedent("""\
      class A:
        class_field = 3
        def __init__(self, arg):
          self.instance_field = arg
        def a_method(self, arg):
          return self.instance_field + arg
        class _simple_nested_cls:
          pass
      """)
    expected_methods = [
        self._make_func(
            name="__init__",
            lineno=3,
            col_offset=2,
            params=[self._make_arg("self", lineno=3, col_offset=15),
                    self._make_arg("arg", lineno=3, col_offset=21)]),
        self._make_func(
            name="a_method",
            lineno=5,
            col_offset=2,
            params=[self._make_arg("self", lineno=5, col_offset=15),
                    self._make_arg("arg", lineno=5, col_offset=21)])
    ]
    expected_fields = [
        definitions.Variable("class_field", lineno=2, col_offset=2),
        definitions.Variable("instance_field", lineno=4, col_offset=4)]
    expected_nests = [
        definitions.Class(name="_simple_nested_cls", lineno=7, col_offset=2,
                          bases=[], keyword_bases=[], decorators=[],
                          fields=[], methods=[], nested_classes=[])
    ]
    expected_class = definitions.Class(
        name="A",
        lineno=1,
        col_offset=0,
        bases=[],
        keyword_bases=[],
        decorators=[],
        fields=expected_fields,
        methods=expected_methods,
        nested_classes=expected_nests)
    # We have to pull apart the parsed class by hand.
    node = self.parse_stmt(class_stmt)
    classfield, init, method, nested = node.body
    # init.body[0] is an ast3.Attribute, and for class fields, there needs to
    # be a definition for the attr instead of the value. So the Variable
    # definition isn't created with from_node, because attr is a str.
    instance_field = init.body[0].targets[0]
    actual_fields = [
        # class_field definition
        definitions.Variable.from_node(classfield.targets[0]),
        # self.instance_field definition
        definitions.Variable(instance_field.attr, instance_field.lineno,
                             instance_field.col_offset)]
    actual_methods = [
        definitions.Function.from_node(init),
        definitions.Function.from_node(method)]
    actual_nests = [definitions.Class.from_node(nested, [], [], [])]
    actual_class = definitions.Class.from_node(
        node, actual_fields, actual_methods, actual_nests)
    self.assertEqual(expected_class, actual_class)


if __name__ == "__main__":
  unittest.main()

