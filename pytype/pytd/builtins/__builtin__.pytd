# -*- mode:Python; coding:utf-8; python-indent:4; indent-tabs-mode:nil -*-

from typing import Generic

# Currently the type annotations are just enough to make the tests
# work. These should be extended.
# TODO(kramm): Add type parameters to many more types. Among them:
#              iterators
#              iterables
# TODO(kramm): Add type parameters to many more methods.
# TODO(kramm): Add mutatable parameter information to all the mutable collections.
# TODO(pludemann): see TODO.txt about reverse operators
# TODO(pludemann): see TODO.txt about whether `bool` should be subclass of `int`
# TODO(pludemann): PYTHONCODE is a no-op right now, but might be useful as
#                  documentation, or needed for class methods (that is, we might
#                  want PYTHONCODE to allow definition of a single method via
#                  __builtin__.pytd, and would need a way of specifrying the
#                  name in __builtin__.py, e.g.:
#                     class Foo:
#                       def Method PYTHONCODE Foo_Method
#                  If not useful, remove.

__file__ = ...  # type:str

T = TypeVar('T')
def __import__(name: str or unicode or bytearray, ...) -> module
def abs PYTHONCODE
def all(iterable) -> bool
def any(iterable) -> bool
def apply(object: function or type, ...) -> NoneType
def bin(number: int or float) -> str
def callable(obj) -> bool
def chr(i: int or long) -> str
def cmp PYTHONCODE
def coerce(x: int, y: int) -> tuple[int]  # tuple[int, int]
def coerce(x: int or float, y: float) -> tuple[float]  # tuple[float, float]
def coerce(x: int or float or complex, y: complex) -> tuple[complex]  # tuple[complex, complex]
def coerce(x: float, y: int) -> tuple[float]  # tuple[float, float]
def coerce(x, y) -> tuple[object]  # tuple[object, object]
def coerce(x: list[T], y: list[T]) -> tuple[list[T]]  # tuple[list, list]
def coerce(x: tuple[T], y: tuple[T]) -> tuple[tuple[T]]  # tuple[tuple, tuple]
def coerce(x: complex, y: int or float) -> tuple[complex]  # tuple[complex, complex]
def coerce(x: function, y: function) -> tuple[function]  # tuple[function, function]
def coerce(x: type, y: type) -> tuple[type]  # tuple[type, type]
def coerce(x: iterator, y: iterator) -> tuple[iterator]  # tuple[iterator, iterator]  # TODO(pludemann): iterator[T] ?
def dir(...) -> list[str]
def divmod(x: int, y: int) -> tuple[int]  # tuple[int, int]
def divmod(x: int or long, y: int or long) -> tuple[long]  # tuple[long, long]
def divmod(x: int or long or float, y: int or long or float) -> tuple[float]  # tuple[float, float]
def divmod(x: int or long or float or complex, y: int or long or float or complex) -> tuple[complex]  # tuple[complex, complex]
def eval(src, ...) -> ?  # Can't say *anything* about the result -- different from "-> object"
def execfile(filename: str, ...) -> NoneType
def filter(function_or_None, sequence: str) -> str
def filter(function_or_None, sequence: bytearray) -> list[int]
def filter(function_or_None, sequence: unicode) -> unicode
def filter(function_or_None, sequence: list[T] or set[T] or iterator[T]) -> list[T]
A = TypeVar('A')
def filter(function_or_None, sequence: tuple[A]) -> tuple[A]
def format(value, ...) -> str
def format(value: unicode, ...) -> unicode
def getattr(value: object, attr: str or unicode, ...) -> ?
def globals() -> dict[str, object]
def hasattr(object, name: str or unicode or bytearray) -> bool
def hash(obj) -> int
def hex(number: int) -> str
def id(obj) -> int
def intern(string: str or bytearray) -> str
def isinstance(object, class_or_type_or_tuple: tuple[type] or type) -> bool
def isinstance(object, class_or_type_or_tuple: tuple[nothing]) -> bool  # Python 2 & 3 allow this
def issubclass(C, B: tuple[type] or type) -> bool
def issubclass(C, B: tuple[nothing]) -> bool
def iter(collection: str) -> iterator[str]
def iter(collection: unicode) -> iterator[unicode]
def iter(collection: bytearray) -> bytearray_iterator
def iter(collection: iterator[T]) -> iterator[T]
def iter(collection: list[T]) -> listiterator[T]
def iter(collection: tuple[T]) -> tupleiterator[T]
def iter(collection: set[T]) -> setiterator[T]
def len(obj) -> int  # TODO(pludemann): leave this out and call obj.__len__() ?
def locals() -> dict[str, object]
def map(function, sequence: list[nothing], ...) -> list[nothing]
def map(function, sequence, ...) -> list
# TODO(pludemann): max(*args: iterable[T], ...) ?
def max(arg1: T, arg2: T) -> T
def max(arg1: T, arg2: T, arg3: T) -> T
def max(arg1, arg2, arg3, ...) -> ?  # TODO(pludemann): handle more args?
def max(iterable: str, ...) -> str
def max(iterable: unicode, ...) -> unicode
def max(iterable: bytearray, ...) -> int  # TODO(pludemann): lint warning if programmer does this?
def max(iterable: list[T], ...) -> T
def max(iterable: tuple[T] or set[T], ...) -> T
def max(iterable: iterator[T], ...) -> T
# TODO(pludemann): min(*args: iterable[T], ...) ?
def min(arg1: T, arg2: T) -> T
def min(arg1: T, arg2: T, arg3: T) -> T
def min(arg1, arg2, arg3, ...) -> ?  # TODO(pludemann): handle more args?
def min(iterable: str, ...) -> str
def min(iterable: bytearray, ...) -> str  # TODO(pludemann): lint warning if programmer does this?
def min(iterable: unicode, ...) -> unicode
def min(iterable: list[T], ...) -> T
def min(iterable: tuple[T], ...) -> T
def min(iterable: set[T], ...) -> T
def min(iterable: iterator[T], ...) -> T
def next PYTHONCODE
def oct(number: int) -> str
# TODO(pludemann): Python3 allows open(int or str or bytes or memoryview, ...)
# TODO(pludemann): Python3: encapsulate details of file (str, bytes) based on mode
def open(name: str or buffer or unicode, ...) -> file
def ord(c: str or unicode) -> int
def pow(x: int, y: int or long, ...) -> float or int or long
def pow(x: long, y: int or long, ...) -> float or long
def pow(x: int or float or complex, y: complex, ...) -> complex
def pow(x: int or float, y: float, ...) -> float
def pow(x: float, y: int, ...) -> float
def pow(x: complex, y: int or float, ...) -> complex
def range(stop: int, ...) -> list[int] or list
def reduce(function, sequence: str, ...) -> str
def reduce(function, sequence: set, ...) -> ?
def repr PYTHONCODE
def round(number: int or float, ...) -> float
def setattr(object, name: str or unicode or bytearray, value) -> NoneType
def sorted(iterable: str or bytearray, ...) -> list[str]
def sorted(iterable: unicode, ...) -> list[unicode]
def sorted(iterable: list[T] or tuple[T] or set[T] or iterator[T], ...) -> list[T]
def sorted(...) -> list[?]
def sum(sequence, ...) -> int
def unichr(i: int) -> unicode
def vars(...) -> dict[str, ?]
def zip(seq1, ...) -> list[tuple]  # TODO(pludemann): zip(seq1: iterator[...], ...) -> list[tuple[...]]
def zip() -> list[nothing]
def exit() -> NoneType raises SystemExit
def quit() -> NoneType raises SystemExit
def input() -> ?
def raw_input() -> str raises EOFError
def print(value, ...) -> NoneType

False = ...  # type: bool
True = ...  # type: bool
NotImplemented = ...  # type: NotImplementedType
None = ...  # type: NoneType
Ellipsis = ...  # type: ellipsis

class object():
    __mro__ = ...  # type: list[?]
    __dict__ = ...  # type: Dict[str, Any]
    __subclasshook__ = ...  # type: Any
    __subclasses__ = ...  # type: Any
    def __init__(self) -> NoneType
    def __sizeof__(self) -> int
    def __repr__(self) -> str
    def __cmp__(self, y) -> bool
    def __eq__(self, other) -> bool
    def __ne__(self, other) -> bool
    def __ge__(self, other) -> bool
    def __gt__(self, other) -> bool
    def __le__(self, other) -> bool
    def __lt__(self, other) -> bool
    # TODO(pludemann): add these methods/attributes:
    # ['__class__', '__delattr__', '__doc__', '__format__', '__getattribute__', '__hash__', '__new__', '__reduce__', '__reduce_ex__', '__setattr__', '__str__', '__subclasshook__']


class NotImplementedType(object):
    pass

class NoneType(object):
    pass

class ellipsis(object):
    pass

# TODO(kramm): Only define this for Python 2
class basestring(object):
    pass

class property(object):  # Also defined in __builtin__.py
    def __init__(self, fget, ...) -> NoneType
    def __get__(self, ...) -> ?
    def __set__(self, ...) -> ?
    def __delete__(self, ...) -> ?

class staticmethod(object):  # Also defined in __builtin__.py
    def __init__(self, func) -> NoneType
    def __get__(self, ...) -> ?

class classmethod(object):  # Also defined in __builtin__.py
    def __init__(self, func) -> NoneType
    def __get__(self, ...) -> ?

class str(basestring, Sequence):  # TODO(kramm): Sequence[str]
    # TODO(pludemann): See comment in TODO.txt for str.__init__
    def __init__(self, object) -> NoneType
    def __init__(self) -> NoneType
    def __add__(self, y: str or bytearray) -> str
    def __add__(self, y: unicode) -> unicode
    def __contains__(self, y: str or unicode or bytearray) -> bool
    def __eq__(self, y: str or bytearray) -> bool
    def __ge__(self, y: str or bytearray) -> bool
    def __getitem__(self, index: int or slice) -> str
    def __getslice__(self, i: int, j: int) -> str
    def __gt__(self, y: str or bytearray) -> bool
    def __le__(self, y: str or bytearray) -> bool
    def __len__(self) -> int
    def __lt__(self, y: str or bytearray) -> bool
    def __mod__(self, y) -> str
    def __mul__(self, n: int) -> str
    def __ne__(self, y: str or bytearray) -> bool
    def capitalize(self) -> str
    def center(self, width: int, ...) -> str
    def count(self, sub: str or unicode or bytearray, ...) -> int
    def decode(self, ...) -> unicode
    def encode(self, ...) -> str
    def endswith(self, suffix: str or unicode or bytearray or tuple[str or unicode or bytearray], ...) -> bool
    def expandtabs(self, ...) -> str
    def find(self, sub: str or unicode or bytearray, ...) -> int
    def format(self, ...) -> str
    def index(self, sub: str or unicode or bytearray, ...) -> int
    def isalnum(self) -> bool
    def isalpha(self) -> bool
    def isdigit(self) -> bool
    def islower(self) -> bool
    def isspace(self) -> bool
    def istitle(self) -> bool
    def isupper(self) -> bool
    def join(self, iterable) -> str
    def join(self, iterable: unicode or iterator) -> str or unicode  # TODO(pludemann): fix
    def ljust(self, width: int, ...) -> str
    def lower(self) -> str
    def lstrip(self, ...) -> str
    def partition(self, sep: str or bytearray) -> tuple[str]  # tuple[str, str, str]
    def partition(self, sep: unicode) -> tuple[unicode]  # tuple[unicode, unicode, unicode]
    def replace(self, old: str or bytearray, new: str or bytearray, ...) -> str
    def replace(self, old: str or unicode or bytearray, new: unicode, ...) -> unicode
    def replace(self, old: unicode, new: str or bytearray, ...) -> unicode
    def rfind(self, sub: str or unicode or bytearray, ...) -> int
    def rindex(self, sub: str or unicode or bytearray, ...) -> int
    def rjust(self, width: int, ...) -> str
    def rpartition(self, sep: str or bytearray) -> tuple[str]  # tuple[str, str, str]
    def rpartition(self, sep: unicode) -> tuple[unicode]  # tuple[unicode, unicode, unicode]
    def rsplit(self, ...) -> list[str]
    def rstrip(self, ...) -> str
    def split(self, ...) -> list[str]
    def splitlines(self, ...) -> list[str]
    def startswith(self, prefix: str or unicode or bytearray or tuple[str or unicode or bytearray], ...) -> bool
    def strip(self, ...) -> str
    def swapcase(self) -> str
    def title(self) -> str
    def translate(self, table: unicode, ...) -> unicode
    def upper(self) -> str
    def zfill(self, width: int) -> str

bytes = str

class unicode(basestring, Sequence):  # TODO(kramm): Sequence[unicode]
    def __init__(self, string, ...) -> NoneType
    def __init__(self) -> NoneType
    def __add__(self, y: str or unicode or bytearray) -> unicode
    def __contains__(self, y: str or unicode or bytearray) -> bool
    def __eq__(self, y: str or unicode or bytearray) -> bool
    def __ge__(self, y: str or unicode or bytearray) -> bool
    def __getitem__(self, index: int or slice) -> unicode
    def __getslice__(self, i: int, j: int) -> unicode
    def __gt__(self, y: str or unicode or bytearray) -> bool
    def __le__(self, y: str or unicode or bytearray) -> bool
    def __len__(self) -> int
    def __lt__(self, y: str or unicode or bytearray) -> bool
    def __mod__(self, y) -> unicode
    def __mul__(self, n: int) -> unicode
    def __ne__(self, y: str or unicode or bytearray) -> bool
    def capitalize(self) -> unicode
    def center(self, width: int, ...) -> unicode
    def count(self, sub: str or unicode or bytearray, ...) -> int
    def decode(self, ...) -> unicode
    def encode(self, ...) -> str
    def endswith(self, suffix: str or unicode or bytearray or tuple[str or unicode or bytearray], ...) -> bool
    def expandtabs(self, ...) -> unicode
    def find(self, sub: str or unicode or bytearray, ...) -> int
    def format(self, ...) -> unicode
    def index(self, sub: str or unicode or bytearray, ...) -> int
    def isalnum(self) -> bool
    def isalpha(self) -> bool
    def isdecimal(self) -> bool
    def isdigit(self) -> bool
    def islower(self) -> bool
    def isnumeric(self) -> bool
    def isspace(self) -> bool
    def istitle(self) -> bool
    def isupper(self) -> bool
    def join(self, iterable) -> unicode
    def ljust(self, width: int, ...) -> unicode
    def lower(self) -> unicode
    def lstrip(self, ...) -> unicode
    def partition(self, sep: str or unicode or bytearray) -> tuple[unicode]  # tuple[unicode, unicode, unicode]
    def replace(self, old: str or unicode or bytearray, new: str or unicode or bytearray, ...) -> unicode
    def rfind(self, sub: str or unicode or bytearray, ...) -> int
    def rindex(self, sub: str or unicode or bytearray, ...) -> int
    def rjust(self, width: int, ...) -> unicode
    def rpartition(self, sep: str or unicode or bytearray) -> tuple[unicode]  # tuple[unicode, unicode, unicode]
    def rsplit(self, ...) -> list[unicode]
    def rstrip(self, ...) -> unicode
    def split(self, ...) -> list[unicode]
    def splitlines(self, ...) -> list[unicode]
    def startswith(self, prefix: str or unicode or bytearray or tuple[str or unicode or bytearray], ...) -> bool
    def strip(self, ...) -> unicode
    def swapcase(self) -> unicode
    def title(self) -> unicode
    def translate(self, table) -> unicode
    def upper(self) -> unicode
    def zfill(self, width: int) -> unicode

class bytearray(Sequence):  # TODO(kramm): Sequence[int]
    def __init__(self, iterable_of_ints) -> NoneType
    def __init__(self) -> NoneType
    def __add__(self, y: str or bytearray) -> bytearray
    def __alloc__(self) -> int
    def __contains__(self, y: str or int or bytearray) -> bool
    def __delitem__(self, y: int) -> NoneType
    def __eq__(self, y: str or bytearray) -> bool
    def __ge__(self, y: str or bytearray) -> bool
    def __getitem__(self, index: int) -> int
    def __gt__(self, y: str or bytearray) -> bool
    def __iter__(self) -> bytearray_iterator
    def __le__(self, y: str or bytearray) -> bool
    def __len__(self) -> int
    def __lt__(self, y: str or bytearray) -> bool
    def __mul__(self, n: int) -> bytearray
    def __ne__(self, y: str or bytearray) -> bool
    def append(self, int: str or int) -> NoneType
    def capitalize(self) -> bytearray
    def center(self, width: int, ...) -> bytearray
    def count(self, sub: str or bytearray, ...) -> int
    def decode(self, ...) -> unicode
    def endswith(self, suffix: str or unicode or bytearray or tuple[str or unicode or bytearray], ...) -> bool
    def expandtabs(self, ...) -> bytearray
    def extend(self, iterable_int) -> NoneType
    def find(self, sub: str or bytearray, ...) -> int
    def fromhex(self, string: str or unicode or bytearray) -> bytearray
    def index(self, sub: str or bytearray, ...) -> int
    def insert(self, index: int, int: str or int) -> NoneType
    def isalnum(self) -> bool
    def isalpha(self) -> bool
    def isdigit(self) -> bool
    def islower(self) -> bool
    def isspace(self) -> bool
    def istitle(self) -> bool
    def isupper(self) -> bool
    def join(self, iterable_of_bytes) -> bytearray
    def ljust(self, width: int, ...) -> bytearray
    def lower(self) -> bytearray
    def lstrip(self, ...) -> bytearray
    def partition(self, sep: str or int or bytearray or iterator) -> tuple[bytearray]  # tuple[bytearray, bytearray, bytearray]
    def pop(self, ...) -> int
    def remove(self, int: str or int) -> NoneType
    def replace(self, old: str or bytearray, new: str or bytearray, ...) -> bytearray
    def reverse(self) -> NoneType
    def rfind(self, sub: str or bytearray, ...) -> int
    def rindex(self, sub: str or bytearray, ...) -> int
    def rjust(self, width: int, ...) -> bytearray
    def rpartition(self, sep: str or int or bytearray or iterator) -> tuple[bytearray]  # tuple[bytearray, bytearray, bytearray]
    def rsplit(self, sep: str or bytearray, ...) -> list[bytearray]
    def rsplit(self) -> list[bytearray]
    def rstrip(self, ...) -> bytearray
    def split(self, ...) -> list[bytearray]
    def splitlines(self, ...) -> list[bytearray]
    def startswith(self, prefix: str or unicode or bytearray or tuple[str or unicode or bytearray], ...) -> bool
    def strip(self, ...) -> bytearray
    def swapcase(self) -> bytearray
    def title(self) -> bytearray
    def upper(self) -> bytearray
    def zfill(self, width: int) -> bytearray

class bytearray_iterator(Iterator):  # TODO(kramm): Iterator[int]
    def __iter__(self) -> bytearray_iterator
    def next(self) -> int

class `dictionary-keyiterator`(Generic[T], Iterator):
    def __iter__(self) -> `dictionary-keyiterator`[T]
    def next(self) -> T

class `dictionary-valueiterator`(Generic[T], Iterator):
    def __iter__(self) -> `dictionary-valueiterator`[T]
    def next(self) -> T

K = TypeVar('K')
V = TypeVar('V')
class `dictionary-itemiterator`(Generic[K, V]):
    def __iter__(self) -> `dictionary-itemiterator`[K, V]
    def next(self) -> tuple[K or V]  # tuple[K, V]  # TODO(pludemann): a pair

class dict_keys(Generic[T], Iterator):
    def __and__(self, y: set[T] or dict_keys[T]) -> set[T]
    def __contains__(self, y: T) -> bool
    def __eq__(self, y: set[T] or dict_keys[T]) -> bool
    def __ge__(self, y: set[T] or dict_keys[T]) -> bool
    def __gt__(self, y: set[T] or dict_keys[T]) -> bool
    def __iter__(self) -> `dictionary-keyiterator`[T]
    def __le__(self, y: set[T] or dict_keys[T]) -> bool
    def __len__(self) -> int
    def __lt__(self, y: set[T] or dict_keys[T]) -> bool
    def __ne__(self, y: set[T] or dict_keys[T]) -> bool
    def __or__(self, y) -> set[T]
    def __sub__(self, y: Iterator[T]) -> set[T]
    def __xor__(self, y) -> set[T]

class dict_values(Generic[T], Iterator):
    def __iter__(self) -> `dictionary-valueiterator`[T]
    def __len__(self) -> int

K = TypeVar('K')
V = TypeVar('V')
class dict_items(Generic[K, V], object):
    # TODO(pludemann): set[pair[K,V]] etc.
    K2 = TypeVar('K2')
    V2 = TypeVar('V2')
    def __and__(self, y: set or dict_items) -> set[tuple[K or V]]
    def __or__(self, y: set or dict_items[K2, V2]) -> set[tuple[K or V or K2 or V2]]
    def __xor__(self, y: set or dict_items[K2, V2]) -> set[tuple[K or V or K2 or V2]]
    def __sub__(self, y: set or dict_items[K2, V2]) -> set[tuple[K or V]]
    def __contains__(self, y) -> bool
    def __iter__(self) -> `dictionary-itemiterator`[K,V]
    def __len__(self) -> int

K = TypeVar('K')
V = TypeVar('V')
# "K" and "V" are hardcoded in other places (e.g. atomic_abstract_value.Dict)
class dict(Generic[K, V], MutableMapping):
    X = TypeVar('X')
    K2 = TypeVar('K2')
    V2 = TypeVar('V2')
    def __init__(self) -> NoneType:
        self := dict[nothing, nothing]
    def __init__(self, list: list[nothing]) -> NoneType:
        self := dict[nothing, nothing]
    def __init__(self, list: list[tuple[X]]) -> NoneType:
        self := dict[X, X]
    def __init__(self, x) -> NoneType
    def __contains__(self, k: K) -> bool
    def __delitem__(self, y: K) -> NoneType
    def __eq__(self, y: dict) -> bool
    def __getitem__(self, index: K) -> V
    def __iter__(self) -> `dictionary-keyiterator`[K]
    def __len__(self) -> int
    def __ne__(self, y: dict) -> bool
    def __setitem__(self, i: K2, y: V2) -> NoneType:
      self := dict[K or K2, V or V2]
    def clear(self) -> NoneType
    def copy(self) -> dict[K, V]
    # TODO(pludemann): dict.fromkeys is also classmethod:
    def fromkeys(self, keys: list[K] or tuple[K]) -> dict[K, NoneType]
    def fromkeys(self, keys: str) -> dict[str, NoneType]
    def fromkeys(self, keys: list[K] or tuple[K], V) -> dict[K, NoneType]
    def fromkeys(self, keys: str, V) -> dict[str, V]
    # TODO(pludemann): fix the following:
    # def fromkeys(self, S: str or bytearray, ...) -> dict[str, NoneType] or dict
    # def fromkeys(self, S: unicode, ...) -> dict[unicode, NoneType] or dict
    # def fromkeys(self, S: list or tuple or set, ...) -> dict[object, NoneType] or dict
    # def fromkeys(self, S: iterator, ...) -> dict[str, NoneType] or dict[unicode, NoneType] or dict
    # def fromkeys(self, S: dict, ...) -> dict[object, NoneType]
    def get(self, k: K) -> V or NoneType
    def get(self, k: K, d: V2) -> V or V2
    def has_key(self, k: K) -> bool
    def items(self) -> list[tuple[K or V]]  # list[tuple[K, V]]
    def iteritems(self) -> `dictionary-itemiterator`[K,V]
    def iterkeys(self) -> `dictionary-keyiterator`[K]
    def itervalues(self) -> `dictionary-valueiterator`[V]
    def keys(self) -> list[K]
    def pop(self, k) -> V
    def pop(self, k, d: V2) -> V or V2
    def popitem(self) -> tuple[K or V]  # tuple[K, V]
    def setdefault(self, k: K2) -> V or NoneType:
        self := dict[K or K2, V or NoneType]
    def setdefault(self, k: K2, v: V2) -> V or V2:
        self := dict[K or K2, V or V2]
    def update(self, E, ...) -> NoneType
    def update(self) -> NoneType
    def values(self) -> list[V]
    def viewitems(self) -> dict_items[K,V]
    def viewkeys(self) -> dict_keys[K]
    def viewvalues(self) -> dict_values

T = TypeVar('T')
class listiterator(Generic[T], Iterator):
    def __iter__(self) -> listiterator[T]
    def next(self) -> T

T = TypeVar('T')
class enumerate(Generic[T], Iterator):
    T2 = TypeVar('T2')
    def __init__(self, iterable: list[T2], ...) -> NoneType:
        self := enumerate[T2]
    def __init__(self, iterable: tuple[T2], ...) -> NoneType:
        self := enumerate[T2]
    def __init__(self, iterable: generator[T2], ...) -> NoneType:
        self := enumerate[T2]
    def __init__(self, ...) -> NoneType:
        self := enumerate[?]
    def __iter__(self) -> enumerate[T]  # enumerate.__iter__() returns itself
    def next(self) -> tuple[int or long or T]  # tuple[int or long, T]

T = TypeVar('T')
class listreverseiterator(Generic[T], Iterator):
    def __iter__(self) -> listreverseiterator[T]
    def next(self) -> T

# "T" is hardcoded in typing.py
T = TypeVar('T')
class list(Generic[T], MutableSequence):
    N = TypeVar('N')
    A = TypeVar('A')
    def __init__(self) -> NoneType:
        self := list[nothing]
    def __init__(self, iterable: list[N] or `dictionary-keyiterator`[N] or `dictionary-valueiterator`[N] or listiterator[N] or listreverseiterator[N] or tupleiterator[N] or setiterator[N] or iterator[N] or `callable-iterator`[N]) -> NoneType:
        self := list[N]
    def __init__(self, iterable: `dictionary-itemiterator`[T,V]) -> NoneType:
        self := list[T]
    def __init__(self, iterable: str) -> NoneType:  # TODO(pludemann): lint warning if programmer does this?
        self := list[str]
    def __init__(self, iterable: bytearray_iterator) -> NoneType:
        self := list[int]
    def __init__(self, iterable: rangeiterator) -> NoneType:
        self := list[int]
    def __init__(self, generator: generator[N]) -> NoneType:
        # TODO(kramm): We should be able to just write "T := N"
        # TODO(pludemann): see comment above -- why does self:=list[int] do the
        #                  the wrong thing for some tests?
        self := list[N]
    def __init__(self, iterable: list[N]) -> NoneType:
        self := list[N]
    def __init__(self, x) -> NoneType:
        # TODO(pludemann): this is a fall-through ... what happens if called
        #                  with __any_object__?
        self := list[?]  # "?" should be x.type.element_type or abc.Iterator
    def __add__(self, y: list[A]) -> list[T or A]
    def __contains__(self, y: T) -> bool
    def __delitem__(self, y: int or slice) -> NoneType
    def __delslice__(self, i: int, j: int) -> NoneType
    # TODO(pludemann): for __eq__, the most likely interpretation is the types
    #                  are the same (i.e.: def __eq__(self, y: list[T]) -> bool)
    #                  but the technically correct intepretation allows them to
    #                  be of different types. We might want to have two flavours
    #                  of type-checking, because better suggested types can be
    #                  generated from the "most likely" inteprerations.
    def __eq__(self, y: list) -> bool
    def __ge__(self, y: list) -> bool
    # if version [ 3: s/int/int or long/  # TODO(pludemann): here and elsewhere
    def __getitem__(self, index: int) -> T
    def __getitem__(self, index: slice) -> list[T]
    def __getslice__(self, i: int, j: int) -> list[T]
    def __gt__(self, y: list) -> bool
    def __iter__(self) -> listiterator[T]
    def __le__(self, y: list) -> bool
    def __len__(self) -> int
    def __lt__(self, y: list) -> bool
    def __mul__(self, n: int) -> list[T]
    def __ne__(self, y: list) -> bool
    def __reversed__(self) -> listreverseiterator[T]
    def __setitem__(self, i: int, y: N) -> NoneType:
      self := list[T or N]
    def __setitem__(self, i: slice, y) -> NoneType:
      self := list[?]
    def __setslice__(self, i: int, j: int, y) -> NoneType
    def append(self, object: A) -> NoneType:
      self := list[T or A]
    def extend(self, i: list[A] or tuple[A] or set[A] or frozenset[A]) -> NoneType:
      self := list[T or A]
    def extend(self, i: ?) -> NoneType:
      self := list[?]
    def count(self, value: T) -> int
    def index(self, value, ...) -> int
    def insert(self, index: int, object: A) -> NoneType:
      self := list[T or A]
    def pop(self) -> T
    def pop(self, i: int) -> T
    def remove(self, value: T) -> NoneType
    def reverse(self) -> NoneType
    def sort(self, ...) -> NoneType

# "reversed" is a type, see PyReversed_Type in Objects/enumobject.c
T = TypeVar('T')
class reversed(Generic[T], Iterator):
    N = TypeVar('N')
    def __init__(self, sequence: list[N]) -> NoneType:
      self := reversed[N]
    def __init__(self, sequence: tuple[N]) -> NoneType:
      self := reversed[N]
    def __init__(self, sequence: str) -> NoneType:
      self := reversed[str]
    def __iter__(self) -> reversed
    def next(self) -> T

# "T" is hardcoded in typing.py
T = TypeVar('T')
class tuple(Generic[T], Sequence):
    A = TypeVar('A')
    def __init__(self, p0) -> NoneType
    def __init__(self) -> NoneType
    def __add__(self, y: tuple[A]) -> tuple[T or A]
    def __contains__(self, y: T) -> bool
    def __eq__(self, y: tuple) -> bool
    def __ge__(self, y: tuple) -> bool
    def __getitem__(self, index: int) -> T
    def __getitem__(self, index: slice) -> tuple[T]
    def __getslice__(self, i: int, j: int) -> tuple[T]
    def __gt__(self, y: tuple) -> bool
    def __iter__(self) -> tupleiterator[T]
    def __le__(self, y: tuple) -> bool
    def __len__(self) -> int
    def __lt__(self, y: tuple) -> bool
    def __mul__(self, n: int) -> tuple[T]
    def __ne__(self, y: tuple) -> bool
    def count(self, value: T) -> int
    def index(self, value, ...) -> int

T = TypeVar('T')
class tupleiterator(Generic[T], Iterator):
    def __iter__(self) -> tupleiterator[T]
    def next(self) -> T

T = TypeVar('T')
class set(Generic[T], MutableSet):
    # TODO(pludemann): some of the combining methods may have wrong set[...] types
    #                  cf: __and__, __or__
    A = TypeVar('A')
    N = TypeVar('N')
    X = TypeVar('X')
    T2 = TypeVar('T2')
    def __init__(self) -> NoneType:
        self := set[nothing]
    def __init__(self, iterable: list[N]) -> NoneType:
        self := set[N]
    def __init__(self, x) -> NoneType:
        self := set[nothing]  # TODO(kramm): should be set[?]
    def __and__(self, y: set[T]) -> set[T]
    def __contains__(self, y) -> bool
    def __eq__(self, y) -> bool
    def __ge__(self, y: set[T]) -> bool
    def __gt__(self, y: set[T]) -> bool
    def __iter__(self) -> setiterator[T]
    def __le__(self, y: set[T]) -> bool
    def __len__(self) -> int
    def __lt__(self, y: set[T]) -> bool
    def __ne__(self, y) -> bool
    def __or__(self, y: set[T2]) -> set[T2]
    def __sub__(self, y: AbstractSet[X]) -> set[T]
    def __xor__(self, y: set[T]) -> set[T]
    def clear(self, ...) -> NoneType
    def copy(self, ...) -> set[T]
    def difference_update(self, ...) -> NoneType
    def intersection_update(self, ...) -> NoneType
    def pop(self) -> T
    def update(self, ...) -> NoneType
    def add(self, object: A) -> NoneType:
        self := set[T or A]
    # Even though these look like instance methods (i.e., you can call
    # {1}.union(x)), they're actually static methods. (Which will accept a
    # variable number of arguments, the first of which can e.g. be self.)
    @staticmethod
    def union(...) -> set[?]
    @staticmethod
    def intersection(...) -> set[?]
    @staticmethod
    def difference(...) -> set[?]

T = TypeVar('T')
class frozenset(Generic[T], AbstractSet):
    N = TypeVar('N')
    T2 = TypeVar('T2')
    def __init__(self) -> NoneType:
        self := frozenset[nothing]
    def __init__(self, x: list[N]) -> NoneType:
        self := frozenset[N]
    def __init__(self, x) -> NoneType:
        self := frozenset[?]
    def __and__(self, y: AbstractSet[T2]) -> frozenset[T]
    def __contains__(self, y) -> bool
    def __eq__(self, y) -> bool
    def __ge__(self, y: AbstractSet[T]) -> bool
    def __gt__(self, y: AbstractSet[T]) -> bool
    def __iter__(self) -> setiterator[T]
    def __le__(self, y: AbstractSet[T]) -> bool
    def __len__(self) -> int
    def __lt__(self, y: AbstractSet[T]) -> bool
    def __ne__(self, y) -> bool
    def __or__(self, y: AbstractSet[T2]) -> frozenset[T or T2]
    def __sub__(self, y: AbstractSet[T2]) -> frozenset[T]
    def __xor__(self, y: AbstractSet[T2]) -> frozenset[T or T2]
    def copy(self, ...) -> frozenset[T]
    def difference(self, ...) -> frozenset[T]
    def intersection(self, ...) -> frozenset[T]
    def union(self, ...) -> frozenset[T]

T = TypeVar('T')
class setiterator(Generic[T], Iterator):
    def __iter__(self) -> setiterator[T]
    def next(self) -> T

class bool(int, SupportsInt, SupportsFloat):
    def __init__(self, x) -> NoneType
    def __init__(self) -> NoneType
    def __abs__(self) -> int
    def __add__(self, y: int or bool) -> int
    def __and__(self, y: bool) -> bool
    def __and__(self, y: int) -> int
    def __coerce__(self, y: int) -> Tuple[bool, int]
    def __coerce__(self, y: bool) -> Tuple[bool, bool]
    def __div__(self, y: int or bool) -> int
    def __divmod__(self, y: int or bool) -> Tuple[int, int]
    def __float__(self) -> float
    def __floordiv__(self, y: int or bool) -> int
    def __hex__(self) -> str
    def __index__(self) -> int
    def __int__(self) -> int
    def __invert__(self) -> int
    def __long__(self) -> long
    def __lshift__(self, y: int) -> int
    def __mod__(self, y: int) -> int
    def __mul__(self, y: int) -> int
    def __neg__(self) -> int
    def __nonzero__(self) -> bool
    def __oct__(self) -> str
    def __or__(self, y: bool) -> bool
    def __or__(self, y: int) -> int
    def __pos__(self) -> int
    def __pow__(self, y: bool) -> int
    def __pow__(self, y: int) -> int or float  # True ** -2 == 0.5
    def __pow__(self, y: int, modulo: int or bool) -> int
    def __rshift__(self, y: int or long) -> int
    def __sub__(self, y: int) -> int
    def __truediv__(self, y: int) -> float
    def __trunc__(self, ...) -> int
    def __xor__(self, y: bool) -> bool
    def __xor__(self, y: int) -> int
    def bit_length(self) -> int
    def conjugate(self, ...) -> int

class int(object):  # TODO(kramm): SupportsInt, SupportsFloat, SupportsAbs)
    def __init__(self, x: int or float, ...) -> NoneType
    def __init__(self) -> NoneType
    def __add__(self, y: int) -> int
    def __add__(self, y: float) -> float
    def __add__(self, y: long) -> long
    def __add__(self, y: complex) -> complex
    def __and__(self, y: int) -> int
    def __and__(self, y: float) -> float
    def __and__(self, y: long) -> long
    def __and__(self, y: complex) -> complex
    def __div__(self, y: int) -> int
    def __div__(self, y: float) -> float
    def __div__(self, y: long) -> long
    def __div__(self, y: complex) -> complex
    def __divmod__(self, y: int) -> Tuple[int, int]
    def __divmod__(self, y: float) -> Tuple[float, float]
    def __divmod__(self, y: long) -> Tuple[long, float]
    def __divmod__(self, y: complex) -> Tuple[complex, complex]
    def __floordiv__(self, y: int) -> int
    def __floordiv__(self, y: float) -> float
    def __floordiv__(self, y: long) -> long
    def __floordiv__(self, y: complex) -> complex
    def __mod__(self, y: int) -> int
    def __mod__(self, y: float) -> float
    def __mod__(self, y: long) -> long
    def __mod__(self, y: complex) -> complex
    def __mul__(self, y: int) -> int
    def __mul__(self, y: float) -> float
    def __mul__(self, y: long) -> long
    def __mul__(self, y: complex) -> complex
    def __mul__(self, n: str) -> str
    def __mul__(self, n: list[T]) -> list[T]
    def __mul__(self, n: tuple[T]) -> tuple[T]
    def __mul__(self, n: buffer) -> str
    def __mul__(self, n: bytearray) -> bytearray
    def __pow__(self, y: int, modulo: int) -> int
    def __pow__(self, y: int) -> int or float  # 1 ** -2 == 0.5
    def __pow__(self, y: float) -> float
    def __pow__(self, y: long) -> long
    def __pow__(self, y: complex) -> complex
    def __rshift__(self, y: int) -> int
    def __rshift__(self, y: long) -> long
    def __sub__(self, y: int) -> int
    def __sub__(self, y: float) -> float
    def __sub__(self, y: long) -> long
    def __sub__(self, y: complex) -> complex
    def __truediv__(self, y: int or float or long) -> float
    def __truediv__(self, y: complex) -> complex
    def __abs__(self) -> int
    def __coerce__(self, y: int) -> Tuple[int, int]
    def __float__(self) -> float
    def __hex__(self) -> str
    def __index__(self) -> int
    def __int__(self) -> int
    def __invert__(self) -> int
    def __long__(self) -> long
    def __lshift__(self, y: int) -> int
    def __lshift__(self, y: long) -> long
    def __neg__(self) -> int
    def __nonzero__(self) -> bool
    def __oct__(self) -> str
    def __or__(self, y: int) -> int
    def __pos__(self) -> int
    def __trunc__(self, ...) -> int
    def __xor__(self, y: int) -> int
    def __eq__(self, y) -> bool
    def __ge__(self, y) -> bool
    def __gt__(self, y) -> bool
    def __le__(self, y) -> bool
    def __lt__(self, y) -> bool
    def __ne__(self, y) -> bool
    def bit_length(self) -> int
    def conjugate(self, ...) -> int

# TODO(pludemann): # if version < 3:
class long(SupportsInt, SupportsFloat, SupportsAbs):
    def __init__(self, x: int or float or long, ...) -> NoneType
    def __init__(self) -> NoneType
    def __abs__(self) -> long
    def __add__(self, y: int or long) -> long
    def __and__(self, y: int or long) -> long
    def __coerce__(self, y: int or long) -> Tuple[long, long]
    def __div__(self, y: int or long) -> long
    def __div__(self, y: float) -> float
    def __div__(self, y: complex) -> complex
    def __divmod__(self, y: int or long) -> Tuple[long]
    def __divmod__(self, y: float) -> Tuple[float]
    def __divmod__(self, y: complex) -> Tuple[complex]
    def __float__(self) -> float
    def __floordiv__(self, y: int or long) -> long
    def __floordiv__(self, y: float) -> float
    def __floordiv__(self, y: complex) -> complex
    def __hex__(self) -> str
    def __index__(self) -> long
    def __int__(self) -> int
    def __invert__(self) -> long
    def __long__(self) -> long
    def __lshift__(self, y: int or long) -> long
    def __mod__(self, y: int or long) -> long
    def __mod__(self, y: float) -> float
    def __mod__(self, y: complex) -> complex
    def __mul__(self, y: int or long) -> long
    def __mul__(self, y: float) -> float
    def __mul__(self, y: complex) -> complex
    def __mul__(self, n: list[T]) -> list[T]
    def __mul__(self, n: tuple[T]) -> tuple[T]
    def __mul__(self, n: bytearray) -> bytearray
    def __neg__(self) -> long
    def __nonzero__(self) -> bool
    def __oct__(self) -> str
    def __or__(self, y: int or long) -> long
    def __pos__(self) -> long
    def __pow__(self, y: long or int, modulo: long or int) -> long raises TypeError
    def __pow__(self, y: int or long) -> long or float  # 1L ** -2 = 0.5
    def __pow__(self, y: float) -> float
    def __pow__(self, y: complex) -> complex
    def __rshift__(self, y: int or long) -> long
    def __sub__(self, y: int or long) -> long
    def __sub__(self, y: float) -> float
    def __sub__(self, y: complex) -> complex
    def __truediv__(self, y: int or long) -> float
    def __trunc__(self, ...) -> long
    def __xor__(self, y: int or long) -> long
    def __eq__(self, y) -> bool
    def __ge__(self, y) -> bool
    def __gt__(self, y) -> bool
    def __le__(self, y) -> bool
    def __lt__(self, y) -> bool
    def __ne__(self, y) -> bool
    def bit_length(self) -> int
    def conjugate(self, ...) -> long

class float(SupportsInt, SupportsFloat, SupportsAbs):
    def __init__(self, x: int or long or float) -> NoneType
    def __init__(self) -> NoneType
    def __abs__(self) -> float
    def __add__(self, y: int or long or float) -> float
    def __add__(self, y: complex) -> complex
    def __coerce__(self, y: int or long or float) -> Tuple[float, float or int]
    def __div__(self, y: int or long or float) -> float
    def __div__(self, y: complex) -> complex
    def __divmod__(self, y: int or long or float) -> Tuple[float, float]
    def __divmod__(self, y: complex) -> Tuple[complex, complex]
    def __float__(self) -> float
    def __floordiv__(self, y: int or long or float) -> float
    def __floordiv__(self, y: complex) -> complex
    def __hex__(self) -> str
    def __index__(self) -> int
    def __int__(self) -> int
    def __invert__(self) -> int
    def __long__(self) -> long
    def __mod__(self, y: int or long or float) -> float
    def __mod__(self, y: complex) -> complex
    def __mul__(self, y: int or long or float) -> float
    def __mul__(self, y: complex) -> complex
    def __neg__(self) -> float
    def __nonzero__(self) -> bool
    def __oct__(self) -> str
    def __pos__(self) -> float
    def __pow__(self, y: int or long or float) -> float
    def __pow__(self, y: complex) -> complex
    def __sub__(self, y: int or long or float) -> float
    def __sub__(self, y: complex) -> complex
    def __truediv__(self, y: int or long or float) -> float
    def __truediv__(self, y: complex) -> complex
    def __trunc__(self, ...) -> int
    def bit_length(self) -> int
    def conjugate(self, ...) -> float or int
    def __eq__(self, y: int or float) -> bool
    def __ge__(self, y: int or float) -> bool
    def __gt__(self, y: int or float) -> bool
    def __le__(self, y: int or float) -> bool
    def __lt__(self, y: int or float) -> bool
    def __ne__(self, y: int or float) -> bool
    def as_integer_ratio(self) -> tuple[int]  # tuple[int, int]
    def fromhex(self, string: str or unicode or bytearray) -> float
    def hex(self) -> str
    def is_integer(self, ...) -> bool

class complex(SupportsAbs):
    def __init__(self, real: int or long or float or complex, ...) -> NoneType
    def __init__(self) -> NoneType
    def __abs__(self) -> float
    def __add__(self, y: int or long or float or complex) -> complex
    def __coerce__(self, y: int or long or float or complex) -> Tuple[complex, complex]
    def __div__(self, y: int or long or float or complex) -> complex
    def __divmod__(self, y: int or long or float or complex) -> Tuple[complex, complex]
    def __eq__(self, y: int or long or float or complex) -> bool
    def __floordiv__(self, y: int or long or float or complex) -> complex
    def __mod__(self, y: int or long or float or complex) -> complex
    def __mul__(self, y: int or long or float or complex) -> complex
    def __ne__(self, y: int or long or float or complex) -> bool
    def __neg__(self) -> complex
    def __nonzero__(self) -> bool
    def __pos__(self) -> complex
    def __pow__(self, y: int or long or float or complex) -> complex
    def __sub__(self, y: int or long or float or complex) -> complex
    def __truediv__(self, y: int or long or float or complex) -> complex
    def conjugate(self) -> complex

class buffer(Sized):
    def __init__(self, object: str or unicode or bytearray or buffer, ...) -> NoneType
    def __add__(self, y: str or unicode or bytearray or buffer) -> str
    def __getitem__(self, index: int) -> str
    def __getslice__(self, i: int, j: int) -> str
    def __len__(self) -> int
    def __mul__(self, n: int) -> str

class file(IO):
    def __init__(self, name: str, ...) -> NoneType
    def __iter__(self) -> file  # TODO(pludemann): This looks wrong ... iterator[str]  ?
    def __enter__(self) -> file
    def __exit__(self, ...) -> NoneType
    def close(self) -> NoneType
    def fileno(self) -> int
    def flush(self) -> NoneType
    def isatty(self) -> bool
    def next(self) -> str
    def read(self, ...) -> str
    def readline(self, ...) -> str
    def readlines(self, ...) -> list[str]
    def seek(self, offset: int or float, ...) -> NoneType
    def tell(self) -> int
    def truncate(self, ...) -> NoneType
    def write(self, str: str or unicode or bytearray) -> NoneType
    def writelines(self, sequence_of_strings) -> NoneType
    def xreadlines(self) -> file

class function(object):
    def __call__(self, ...) -> ?
    def __get__(self, obj, ...) -> instancemethod

T = TypeVar('T')
class generator(Generic[T], object):  # "T" is also hardcoded in abstract.py:Generator
    def __iter__(self) -> generator[T]
    def send(self, arg) -> ?  # TODO(pludemann): or should be "-> T" ?  or needs 2 parameter types for generator?
    def close(self) -> NoneType
    def next(self) -> T

class instancemethod(object):
    def __init__(self, function: function or type or instancemethod, instance, cls) -> NoneType
    def __get__(self, obj, ...) -> instancemethod

class module(object):
    __file__ = ...  # type: str
    __name__ = ...  # type: str
    __doc__ = ...  # type: AnyStr
    __package__ = ...  # type: Optional[str]
    def __init__(self, name: str or bytearray, doc = ...) -> NoneType

class slice(object):
    def __init__(self, stop, ...) -> NoneType
    def indices(self, len: int) -> tuple[int]  # tuple[int, int, int]

class memoryview(object):
    def __init__(self, object: str or bytearray or memoryview) -> NoneType
    def __eq__(self, y: str or bytearray or memoryview) -> bool
    def __getitem__(self, index: int) -> str
    def __len__(self) -> int
    def __ne__(self, y: str or bytearray or memoryview) -> bool
    def tobytes(self, ...) -> str
    def tolist(self, ...) -> list[int]

class type(object):
    __name__ = ...  # type: str
    def __init__(self, object: Any) -> NoneType
    def __len__(self, p0: str or bytearray) -> int  # TODO(pludemann): remove?

T = TypeVar('T')
class iterator(Generic[T], object):
    def __iter__(self) -> iterator[T]
    def next(self) -> T

class `callable-iterator`(Generic[T], object):  # TODO(pludemann): is this correct?
    def __iter__(self) -> `callable-iterator`[T]
    def next(self) -> T

class super(object):
    # This constructor constructs the super object itself but also handles the
    # case of doing super(...).__init__(...).
    def __init__(self, ...) -> NoneType
    def __get__(self, obj, ...) -> super
    def __new__(self, ...) -> super

class xrange(Sized, Iterable, Reversible):
    def __init__(self, stop: int, ...) -> NoneType
    def __getitem__(self, index: int) -> int
    def __iter__(self) -> rangeiterator
    def __len__(self) -> int
    def __reversed__(self, ...) -> rangeiterator

class rangeiterator(object):
    def __iter__(self) -> rangeiterator
    def next(self) -> int

# From Python/objects/capsule.c. Used e.g. by datetime.datetime_CAPI
class PyCapsule(object):
    pass

# types.CodeType, a.k.a., [type 'code']
class code(object):
    pass

class ArithmeticError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class AssertionError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class AttributeError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class BaseException(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class BufferError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class BytesWarning(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class DeprecationWarning(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class EOFError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class EnvironmentError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class Exception(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class FloatingPointError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class FutureWarning(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class GeneratorExit(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class IOError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class ImportError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class ImportWarning(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class IndentationError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class IndexError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class KeyError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class KeyboardInterrupt(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class LookupError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class MemoryError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class NameError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class NotImplementedError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class OSError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class OverflowError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class PendingDeprecationWarning(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class ReferenceError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class RuntimeError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class RuntimeWarning(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class StandardError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class StopIteration(object):
    def __init__(self, p0) -> NoneType
    def __init__(self) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class SyntaxError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class SyntaxWarning(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class SystemError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class SystemExit(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class TabError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class TypeError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class UnboundLocalError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class UnicodeError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class UnicodeWarning(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class UserWarning(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class ValueError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class Warning(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

class ZeroDivisionError(object):
    def __init__(self, ...) -> NoneType
    def __getslice__(self, i: int, j: int) -> tuple  # TODO(pludemann): tuple[???]
    def __unicode__(self, ...) -> unicode

