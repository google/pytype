import __future__
import sys
if sys.version_info < (3,):
    import attr._compat
else:
    import types
import attr.exceptions
import threading
from typing import Any, Callable, Dict, List, NoReturn, Tuple, Type, TypeVar, Union

DefaultAlreadySetError: Type[attr.exceptions.DefaultAlreadySetError]
FrozenInstanceError: Type[attr.exceptions.FrozenInstanceError]
NOTHING: _Nothing
NotAnAttrsClassError: Type[attr.exceptions.NotAnAttrsClassError]
PY2: bool
PythonTooOldError: Type[attr.exceptions.PythonTooOldError]
UnannotatedAttributeError: Type[attr.exceptions.UnannotatedAttributeError]
WARNING_CMP_ISINSTANCE: str
_AndValidator: Any
_Attributes: Union[Callable, Type[property]]
_a: List[Attribute]
_already_repring: threading.local
_classvar_prefixes: Tuple[str, str, str]
_config: module
if sys.version_info < (3,):
    _empty_metadata_singleton: attr._compat.ReadOnlyDict
    a: Attribute
    name: str
else:
    _empty_metadata_singleton: types.MappingProxyType[nothing, nothing]
_hash_cache_field: str
_init_converter_pat: str
_init_factory_pat: str
_tuple_property_pat: str
absolute_import: __future__._Feature
copy: module
division: __future__._Feature
hashlib: module
linecache: module
ordered_dict: Type[dict]
print_function: __future__._Feature
set_closure_cell: Any
sys: module
threading: module
warnings: module

_T0 = TypeVar('_T0')
_TAttribute = TypeVar('_TAttribute', bound=Attribute)
_T_ClassBuilder = TypeVar('_T_ClassBuilder', bound=_ClassBuilder)
_T_Nothing = TypeVar('_T_Nothing', bound=_Nothing)

class Attribute(object):
    __slots__ = ["cmp", "converter", "default", "hash", "init", "kw_only", "metadata", "name", "repr", "type", "validator"]
    __doc__: str
    __eq__: Any
    __hash__: Any
    convert: Any
    def __ge__(self, other) -> Any: ...
    def __getstate__(self) -> tuple: ...
    def __gt__(self, other) -> Any: ...
    def __init__(self, name, default, validator, repr, cmp, hash, init, convert = ..., metadata = ..., type = ..., converter = ..., kw_only = ...) -> None: ...
    def __le__(self, other) -> Any: ...
    def __lt__(self, other) -> Any: ...
    def __ne__(self: Union[Attribute, _CountingAttr], other) -> Union[NotImplementedType, bool]: ...
    def __setattr__(self, name, value) -> NoReturn: ...
    def __setstate__(self, state) -> None: ...
    def _assoc(self: _TAttribute, **changes) -> _TAttribute: ...
    def _setattrs(self, name_values_pairs) -> None: ...
    @classmethod
    def from_counting_attr(cls, name, ca, type = ...) -> Any: ...

class _ClassBuilder(object):
    __slots__ = ["_attr_names", "_attrs", "_base_attr_map", "_base_names", "_cache_hash", "_cls", "_cls_dict", "_delete_attribs", "_frozen", "_has_post_init", "_slots", "_weakref_slot"]
    __doc__: str
    _attr_names: tuple
    _attrs: Any
    _base_attr_map: Any
    _base_names: set
    _cache_hash: Any
    _cls: Any
    _cls_dict: dict
    _delete_attribs: bool
    _frozen: Any
    _has_post_init: bool
    _slots: Any
    _weakref_slot: Any
    def __init__(self, cls, these, slots, frozen, weakref_slot, auto_attribs, kw_only, cache_hash) -> None: ...
    def _add_method_dunders(self, method: _T0) -> _T0: ...
    def _create_slots_class(self) -> Any: ...
    def _patch_original_class(self) -> Any: ...
    def add_cmp(self: _T_ClassBuilder) -> _T_ClassBuilder: ...
    def add_hash(self: _T_ClassBuilder) -> _T_ClassBuilder: ...
    def add_init(self: _T_ClassBuilder) -> _T_ClassBuilder: ...
    def add_repr(self: _T_ClassBuilder, ns) -> _T_ClassBuilder: ...
    def add_str(self: _T_ClassBuilder) -> _T_ClassBuilder: ...
    def build_class(self) -> Any: ...
    def make_unhashable(self: _T_ClassBuilder) -> _T_ClassBuilder: ...

class _CountingAttr(object):
    __slots__ = ["_default", "_validator", "cmp", "converter", "counter", "hash", "init", "kw_only", "metadata", "repr", "type"]
    __attrs_attrs__: Tuple[Attribute, ...]
    __doc__: str
    __eq__: Any
    _default: Any
    _validator: Any
    cls_counter: int
    cmp: Any
    converter: Any
    counter: int
    hash: Any
    init: Any
    kw_only: Any
    metadata: Any
    repr: Any
    type: Any
    def __ge__(self, other) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __init__(self, default, validator, repr, cmp, hash, init, converter, metadata, type, kw_only) -> None: ...
    def __le__(self, other) -> Any: ...
    def __lt__(self, other) -> Any: ...
    def __ne__(self: Union[Attribute, _CountingAttr], other) -> Union[NotImplementedType, bool]: ...
    def default(self, meth: _T0) -> _T0: ...
    def validator(self, meth: _T0) -> _T0: ...

class _Nothing(object):
    __doc__: str
    _singleton: _Nothing
    def __new__(cls: Type[_T_Nothing]) -> _T_Nothing: ...

def Factory(factory: Union[Callable[[], _T0], Callable[[Any], _T0]], takes_self: bool = ...) -> _T0: ...
def __ne__(self: Union[Attribute, _CountingAttr], other) -> Union[NotImplementedType, bool]: ...
def _add_cmp(cls: _T0, attrs = ...) -> _T0: ...
def _add_hash(cls: _T0, attrs) -> _T0: ...
def _add_init(cls: _T0, frozen) -> _T0: ...
def _add_repr(cls: _T0, ns = ..., attrs = ...) -> _T0: ...
def _attrs(maybe_cls = ..., these = ..., repr_ns = ..., repr = ..., cmp = ..., hash = ..., init = ..., slots = ..., frozen = ..., weakref_slot = ..., str = ..., auto_attribs = ..., kw_only = ..., cache_hash = ...) -> Any: ...
def _attrs_to_init_script(attrs, frozen, slots, post_init, cache_hash, base_attr_map) -> Tuple[str, Dict[str, Any], dict]: ...
def _attrs_to_tuple(obj, attrs) -> tuple: ...
def _counter_getter(e) -> Any: ...
def _frozen_delattrs(self, name) -> NoReturn: ...
def _frozen_setattrs(self, name, value) -> NoReturn: ...
def _get_annotations(cls) -> Any: ...
def _has_frozen_base_class(cls) -> Any: ...
def _is_class_var(annot) -> bool: ...
def _is_slot_attr(a_name, base_attr_map) -> Any: ...
def _is_slot_cls(cls) -> bool: ...
def _make_attr_tuple_class(cls_name, attr_names) -> Union[Callable, Type[property]]: ...
def _make_cmp(attrs) -> Tuple[Any, Callable[[Any, Any], Any], Callable[[Any, Any], Any], Callable[[Any, Any], Any], Callable[[Any, Any], Any], Callable[[Any, Any], Any]]: ...
def _make_hash(attrs, frozen, cache_hash) -> Any: ...
def _make_init(attrs, post_init, frozen, slots, cache_hash, base_attr_map) -> Any: ...
def _make_repr(attrs, ns) -> Callable[[Any], Any]: ...
def _obj_setattr(self: object, name, value) -> None: ...
def _transform_attrs(cls, these, auto_attribs, kw_only) -> Union[Callable[[Any], Any], property]: ...
def and_(*validators) -> Any: ...
def attrib(default = ..., validator = ..., repr = ..., cmp = ..., hash = ..., init: bool = ..., convert = ..., metadata = ..., type = ..., converter = ..., factory = ..., kw_only = ...) -> _CountingAttr: ...
def attrs(maybe_cls = ..., these = ..., repr_ns = ..., repr = ..., cmp = ..., hash = ..., init: bool = ..., slots = ..., frozen = ..., weakref_slot = ..., str = ..., auto_attribs = ..., kw_only = ..., cache_hash = ...) -> Any: ...
def fields(cls) -> Any: ...
def fields_dict(cls) -> dict: ...
def isclass(klass) -> bool: ...
def itemgetter(*items) -> Callable[[Any], tuple]: ...
def iteritems(d) -> Any: ...
def make_class(name, attrs, bases = ..., **attributes_arguments) -> Any: ...
if sys.version_info < (3,):
    def metadata_proxy(d) -> attr._compat.ReadOnlyDict: ...
else:
    def metadata_proxy(d) -> types.MappingProxyType[nothing, nothing]: ...
def validate(inst) -> None: ...